{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addNode = addNode;\nexports.attachListeners = attachListeners;\nexports.getResponderNode = getResponderNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\nvar _utils = require(\"./utils\");\nvar _ResponderTouchHistoryStore = require(\"./ResponderTouchHistoryStore\");\nvar _canUseDom = _interopRequireDefault(require(\"../canUseDom\"));\nvar emptyObject = {};\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nvar responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  if (eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent, responderTouchHistoryStore);\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n      id = _currentResponder.id,\n      node = _currentResponder.node;\n    var _getResponderConfig = getResponderConfig(id),\n      onResponderStart = _getResponderConfig.onResponderStart,\n      onResponderMove = _getResponderConfig.onResponderMove,\n      onResponderEnd = _getResponderConfig.onResponderEnd,\n      onResponderRelease = _getResponderConfig.onResponderRelease,\n      onResponderTerminate = _getResponderConfig.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || eventType === 'contextmenu' || eventType === 'blur' && eventTarget === window || eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || isScrollEvent && trackedTouchCount === 0 || isScrollEvent && eventTarget.contains(node) && eventTarget !== node || isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches);\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n      nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id: id,\n            node: node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n        if (_result != null) {\n          return _result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n    currentId = _currentResponder2.id,\n    currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n    node = wantsResponder.node;\n  var _getResponderConfig2 = getResponderConfig(id),\n    onResponderGrant = _getResponderConfig2.onResponderGrant,\n    onResponderReject = _getResponderConfig2.onResponderReject;\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  } else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n    var allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = ['mousedown', 'mousemove', 'mouseup', 'dragstart', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'contextmenu', 'select', 'selectionchange'];\nfunction attachListeners() {\n  if (_canUseDom.default && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n    id = _currentResponder3.id,\n    node = _currentResponder3.node;\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n      onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({}, responderTouchHistoryStore);\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\nfunction getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"names":["_createResponderEvent","_interopRequireDefault","require","_ResponderEventTypes","_utils","_ResponderTouchHistoryStore","_canUseDom","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","responderTouchHistoryStore","ResponderTouchHistoryStore","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isStartish","isPrimaryPointerDown","isMoveEvent","isMoveish","isEndEvent","isEndish","isScrollEvent","isScroll","isSelectionChangeEvent","isSelectionChange","responderEvent","createResponderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","getResponderPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","getLowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","isCancelish","window","contains","relatedTarget","hasValidSelection","isReleaseEvent","hasTargetTouches","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","canUseDOM","__reactResponderSystemActive","addEventListener","forEach","document","addNode","setResponderId","set","removeNode","terminateResponder","has","delete","_currentResponder3","_getResponderConfig4","event","getResponderNode"],"sources":["C:/Users/Anirudh/New folder/amplify/frontend/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js"],"sourcesContent":["/**\r\n * Copyright (c) Nicolas Gallagher\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\r\n\r\n/**\r\n * RESPONDER EVENT SYSTEM\r\n *\r\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\r\n * that pointer interactions are exclusive to that view and none other. The \"interaction\r\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\r\n * pointers continue to be active.\r\n *\r\n * Responder being granted:\r\n *\r\n * A view can become the \"responder\" after the following events:\r\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\r\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\r\n *  * \"scroll\" (while a pointer is down)\r\n *  * \"selectionchange\" (while a pointer is down)\r\n *\r\n * If nothing is already the \"responder\", the event propagates to (capture) and from\r\n * (bubble) the event target until a view returns `true` for\r\n * `on*ShouldSetResponder(Capture)`.\r\n *\r\n * If something is already the responder, the event propagates to (capture) and from\r\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\r\n * Then negotiation happens between the current \"responder\" and a view that wants to\r\n * become the \"responder\": see the timing diagram below.\r\n *\r\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\r\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\r\n * system must result in the current \"responder\" being notified that it no longer has\r\n * the \"interaction lock\" - the native system has taken over.\r\n *\r\n * Responder being released:\r\n *\r\n * As soon as there are no more active pointers that *started* inside descendants\r\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\r\n * current \"responder\", and the responder lock is released.\r\n *\r\n * Typical sequence of events:\r\n *  * startShouldSetResponder\r\n *  * responderGrant/Reject\r\n *  * responderStart\r\n *  * responderMove\r\n *  * responderEnd\r\n *  * responderRelease\r\n */\r\n\r\n/*                                             Negotiation Performed\r\n                                             +-----------------------+\r\n                                            /                         \\\r\nProcess low level events to    +     Current Responder      +   wantsResponderID\r\ndetermine who to perform negot-|   (if any exists at all)   |\r\niation/transition              | Otherwise just pass through|\r\n-------------------------------+----------------------------+------------------+\r\nBubble to find first ID        |                            |\r\nto return true:wantsResponderID|                            |\r\n                               |                            |\r\n     +--------------+          |                            |\r\n     | onTouchStart |          |                            |\r\n     +------+-------+    none  |                            |\r\n            |            return|                            |\r\n+-----------v-------------+true| +------------------------+ |\r\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\r\n+-----------+-------------+    | +------------------------+ |          |\r\n            |                  |                            | +--------+-------+\r\n            | returned true for|       false:REJECT +-------->|onResponderReject\r\n            | wantsResponderID |                    |       | +----------------+\r\n            | (now attempt     | +------------------+-----+ |\r\n            |  handoff)        | | onResponder            | |\r\n            +------------------->|    TerminationRequest  | |\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |         true:GRANT +-------->|onResponderGrant|\r\n                               |                            | +--------+-------+\r\n                               | +------------------------+ |          |\r\n                               | | onResponderTerminate   |<-----------+\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |                    +-------->|onResponderStart|\r\n                               |                            | +----------------+\r\nBubble to find first ID        |                            |\r\nto return true:wantsResponderID|                            |\r\n                               |                            |\r\n     +-------------+           |                            |\r\n     | onTouchMove |           |                            |\r\n     +------+------+     none  |                            |\r\n            |            return|                            |\r\n+-----------v-------------+true| +------------------------+ |\r\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\r\n+-----------+-------------+    | +------------------------+ |          |\r\n            |                  |                            | +--------+-------+\r\n            | returned true for|       false:REJECT +-------->|onResponderReject\r\n            | wantsResponderID |                    |       | +----------------+\r\n            | (now attempt     | +------------------+-----+ |\r\n            |  handoff)        | |   onResponder          | |\r\n            +------------------->|      TerminationRequest| |\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |         true:GRANT +-------->|onResponderGrant|\r\n                               |                            | +--------+-------+\r\n                               | +------------------------+ |          |\r\n                               | |   onResponderTerminate |<-----------+\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |                    +-------->|onResponderMove |\r\n                               |                            | +----------------+\r\n                               |                            |\r\n                               |                            |\r\n      Some active touch started|                            |\r\n      inside current responder | +------------------------+ |\r\n      +------------------------->|      onResponderEnd    | |\r\n      |                        | +------------------------+ |\r\n  +---+---------+              |                            |\r\n  | onTouchEnd  |              |                            |\r\n  +---+---------+              |                            |\r\n      |                        | +------------------------+ |\r\n      +------------------------->|     onResponderEnd     | |\r\n      No active touches started| +-----------+------------+ |\r\n      inside current responder |             |              |\r\n                               |             v              |\r\n                               | +------------------------+ |\r\n                               | |    onResponderRelease  | |\r\n                               | +------------------------+ |\r\n                               |                            |\r\n                               +                            + */\r\n\r\nimport createResponderEvent from './createResponderEvent';\r\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from './ResponderEventTypes';\r\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from './utils';\r\nimport { ResponderTouchHistoryStore } from './ResponderTouchHistoryStore';\r\nimport canUseDOM from '../canUseDom';\r\n\r\n/* ------------ TYPES ------------ */\r\n\r\nvar emptyObject = {};\r\n\r\n/* ------------ IMPLEMENTATION ------------ */\r\n\r\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\r\n  bubbles: true\r\n}];\r\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\r\n  bubbles: true\r\n}];\r\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\r\n  bubbles: false\r\n}];\r\nvar shouldSetResponderEvents = {\r\n  touchstart: startRegistration,\r\n  mousedown: startRegistration,\r\n  touchmove: moveRegistration,\r\n  mousemove: moveRegistration,\r\n  scroll: scrollRegistration\r\n};\r\nvar emptyResponder = {\r\n  id: null,\r\n  idPath: null,\r\n  node: null\r\n};\r\nvar responderListenersMap = new Map();\r\nvar isEmulatingMouseEvents = false;\r\nvar trackedTouchCount = 0;\r\nvar currentResponder = {\r\n  id: null,\r\n  node: null,\r\n  idPath: null\r\n};\r\nvar responderTouchHistoryStore = new ResponderTouchHistoryStore();\r\nfunction changeCurrentResponder(responder) {\r\n  currentResponder = responder;\r\n}\r\nfunction getResponderConfig(id) {\r\n  var config = responderListenersMap.get(id);\r\n  return config != null ? config : emptyObject;\r\n}\r\n\r\n/**\r\n * Process native events\r\n *\r\n * A single event listener is used to manage the responder system.\r\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\r\n * are interpreted in terms of the Responder System and checked to see if\r\n * the responder should be transferred. Each host node that is attached to\r\n * the Responder System has an ID, which is used to look up its associated\r\n * callbacks.\r\n */\r\nfunction eventListener(domEvent) {\r\n  var eventType = domEvent.type;\r\n  var eventTarget = domEvent.target;\r\n\r\n  /**\r\n   * Manage emulated events and early bailout.\r\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\r\n   * necessary to manually manage the mess of browser touch/mouse events.\r\n   * And bailout early for termination events when there is no active responder.\r\n   */\r\n\r\n  // Flag when browser may produce emulated events\r\n  if (eventType === 'touchstart') {\r\n    isEmulatingMouseEvents = true;\r\n  }\r\n  // Remove flag when browser will not produce emulated events\r\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\r\n    isEmulatingMouseEvents = false;\r\n  }\r\n  // Ignore various events in particular circumstances\r\n  if (\r\n  // Ignore browser emulated mouse events\r\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||\r\n  // Ignore mousemove if a mousedown didn't occur first\r\n  eventType === 'mousemove' && trackedTouchCount < 1) {\r\n    return;\r\n  }\r\n  // Remove flag after emulated events are finished\r\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\r\n    if (trackedTouchCount === 0) {\r\n      isEmulatingMouseEvents = false;\r\n    }\r\n    return;\r\n  }\r\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\r\n  var isMoveEvent = isMoveish(eventType);\r\n  var isEndEvent = isEndish(eventType);\r\n  var isScrollEvent = isScroll(eventType);\r\n  var isSelectionChangeEvent = isSelectionChange(eventType);\r\n  var responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);\r\n\r\n  /**\r\n   * Record the state of active pointers\r\n   */\r\n\r\n  if (isStartEvent || isMoveEvent || isEndEvent) {\r\n    if (domEvent.touches) {\r\n      trackedTouchCount = domEvent.touches.length;\r\n    } else {\r\n      if (isStartEvent) {\r\n        trackedTouchCount = 1;\r\n      } else if (isEndEvent) {\r\n        trackedTouchCount = 0;\r\n      }\r\n    }\r\n    responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\r\n  }\r\n\r\n  /**\r\n   * Responder System logic\r\n   */\r\n\r\n  var eventPaths = getResponderPaths(domEvent);\r\n  var wasNegotiated = false;\r\n  var wantsResponder;\r\n\r\n  // If an event occured that might change the current responder...\r\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\r\n    // If there is already a responder, prune the event paths to the lowest common ancestor\r\n    // of the existing responder and deepest target of the event.\r\n    var currentResponderIdPath = currentResponder.idPath;\r\n    var eventIdPath = eventPaths.idPath;\r\n    if (currentResponderIdPath != null && eventIdPath != null) {\r\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\r\n      if (lowestCommonAncestor != null) {\r\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\r\n        // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\r\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\r\n        eventPaths = {\r\n          idPath: eventIdPath.slice(index),\r\n          nodePath: eventPaths.nodePath.slice(index)\r\n        };\r\n      } else {\r\n        eventPaths = null;\r\n      }\r\n    }\r\n    if (eventPaths != null) {\r\n      // If a node wants to become the responder, attempt to transfer.\r\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\r\n      if (wantsResponder != null) {\r\n        // Sets responder if none exists, or negotates with existing responder.\r\n        attemptTransfer(responderEvent, wantsResponder);\r\n        wasNegotiated = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\r\n  if (currentResponder.id != null && currentResponder.node != null) {\r\n    var _currentResponder = currentResponder,\r\n      id = _currentResponder.id,\r\n      node = _currentResponder.node;\r\n    var _getResponderConfig = getResponderConfig(id),\r\n      onResponderStart = _getResponderConfig.onResponderStart,\r\n      onResponderMove = _getResponderConfig.onResponderMove,\r\n      onResponderEnd = _getResponderConfig.onResponderEnd,\r\n      onResponderRelease = _getResponderConfig.onResponderRelease,\r\n      onResponderTerminate = _getResponderConfig.onResponderTerminate,\r\n      onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\r\n    responderEvent.bubbles = false;\r\n    responderEvent.cancelable = false;\r\n    responderEvent.currentTarget = node;\r\n\r\n    // Start\r\n    if (isStartEvent) {\r\n      if (onResponderStart != null) {\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\r\n        onResponderStart(responderEvent);\r\n      }\r\n    }\r\n    // Move\r\n    else if (isMoveEvent) {\r\n      if (onResponderMove != null) {\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\r\n        onResponderMove(responderEvent);\r\n      }\r\n    } else {\r\n      var isTerminateEvent = isCancelish(eventType) ||\r\n      // native context menu\r\n      eventType === 'contextmenu' ||\r\n      // window blur\r\n      eventType === 'blur' && eventTarget === window ||\r\n      // responder (or ancestors) blur\r\n      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||\r\n      // native scroll without using a pointer\r\n      isScrollEvent && trackedTouchCount === 0 ||\r\n      // native scroll on node that is parent of the responder (allow siblings to scroll)\r\n      isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||\r\n      // native select/selectionchange on node\r\n      isSelectionChangeEvent && hasValidSelection(domEvent);\r\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\r\n\r\n      // End\r\n      if (isEndEvent) {\r\n        if (onResponderEnd != null) {\r\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\r\n          onResponderEnd(responderEvent);\r\n        }\r\n      }\r\n      // Release\r\n      if (isReleaseEvent) {\r\n        if (onResponderRelease != null) {\r\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\r\n          onResponderRelease(responderEvent);\r\n        }\r\n        changeCurrentResponder(emptyResponder);\r\n      }\r\n      // Terminate\r\n      if (isTerminateEvent) {\r\n        var shouldTerminate = true;\r\n\r\n        // Responders can still avoid termination but only for these events.\r\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\r\n          // Only call this function is it wasn't already called during negotiation.\r\n          if (wasNegotiated) {\r\n            shouldTerminate = false;\r\n          } else if (onResponderTerminationRequest != null) {\r\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\r\n            if (onResponderTerminationRequest(responderEvent) === false) {\r\n              shouldTerminate = false;\r\n            }\r\n          }\r\n        }\r\n        if (shouldTerminate) {\r\n          if (onResponderTerminate != null) {\r\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\r\n            onResponderTerminate(responderEvent);\r\n          }\r\n          changeCurrentResponder(emptyResponder);\r\n          isEmulatingMouseEvents = false;\r\n          trackedTouchCount = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Walk the event path to/from the target node. At each node, stop and call the\r\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\r\n * call \"stopPropagation\" on the event, stop searching for a responder.\r\n */\r\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\r\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\r\n\r\n  if (shouldSetCallbacks != null) {\r\n    var idPath = eventPaths.idPath,\r\n      nodePath = eventPaths.nodePath;\r\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\r\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\r\n    var bubbles = shouldSetCallbacks[2].bubbles;\r\n    var check = function check(id, node, callbackName) {\r\n      var config = getResponderConfig(id);\r\n      var shouldSetCallback = config[callbackName];\r\n      if (shouldSetCallback != null) {\r\n        responderEvent.currentTarget = node;\r\n        if (shouldSetCallback(responderEvent) === true) {\r\n          // Start the path from the potential responder\r\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\r\n          return {\r\n            id,\r\n            node,\r\n            idPath: prunedIdPath\r\n          };\r\n        }\r\n      }\r\n    };\r\n\r\n    // capture\r\n    for (var i = idPath.length - 1; i >= 0; i--) {\r\n      var id = idPath[i];\r\n      var node = nodePath[i];\r\n      var result = check(id, node, shouldSetCallbackCaptureName);\r\n      if (result != null) {\r\n        return result;\r\n      }\r\n      if (responderEvent.isPropagationStopped() === true) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // bubble\r\n    if (bubbles) {\r\n      for (var _i = 0; _i < idPath.length; _i++) {\r\n        var _id = idPath[_i];\r\n        var _node = nodePath[_i];\r\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\r\n        if (_result != null) {\r\n          return _result;\r\n        }\r\n        if (responderEvent.isPropagationStopped() === true) {\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      var _id2 = idPath[0];\r\n      var _node2 = nodePath[0];\r\n      var target = domEvent.target;\r\n      if (target === _node2) {\r\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Attempt to transfer the responder.\r\n */\r\nfunction attemptTransfer(responderEvent, wantsResponder) {\r\n  var _currentResponder2 = currentResponder,\r\n    currentId = _currentResponder2.id,\r\n    currentNode = _currentResponder2.node;\r\n  var id = wantsResponder.id,\r\n    node = wantsResponder.node;\r\n  var _getResponderConfig2 = getResponderConfig(id),\r\n    onResponderGrant = _getResponderConfig2.onResponderGrant,\r\n    onResponderReject = _getResponderConfig2.onResponderReject;\r\n  responderEvent.bubbles = false;\r\n  responderEvent.cancelable = false;\r\n  responderEvent.currentTarget = node;\r\n\r\n  // Set responder\r\n  if (currentId == null) {\r\n    if (onResponderGrant != null) {\r\n      responderEvent.currentTarget = node;\r\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\r\n      onResponderGrant(responderEvent);\r\n    }\r\n    changeCurrentResponder(wantsResponder);\r\n  }\r\n  // Negotiate with current responder\r\n  else {\r\n    var _getResponderConfig3 = getResponderConfig(currentId),\r\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\r\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\r\n    var allowTransfer = true;\r\n    if (onResponderTerminationRequest != null) {\r\n      responderEvent.currentTarget = currentNode;\r\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\r\n      if (onResponderTerminationRequest(responderEvent) === false) {\r\n        allowTransfer = false;\r\n      }\r\n    }\r\n    if (allowTransfer) {\r\n      // Terminate existing responder\r\n      if (onResponderTerminate != null) {\r\n        responderEvent.currentTarget = currentNode;\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\r\n        onResponderTerminate(responderEvent);\r\n      }\r\n      // Grant next responder\r\n      if (onResponderGrant != null) {\r\n        responderEvent.currentTarget = node;\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\r\n        onResponderGrant(responderEvent);\r\n      }\r\n      changeCurrentResponder(wantsResponder);\r\n    } else {\r\n      // Reject responder request\r\n      if (onResponderReject != null) {\r\n        responderEvent.currentTarget = node;\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\r\n        onResponderReject(responderEvent);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* ------------ PUBLIC API ------------ */\r\n\r\n/**\r\n * Attach Listeners\r\n *\r\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\r\n * this system.\r\n */\r\nvar documentEventsCapturePhase = ['blur', 'scroll'];\r\nvar documentEventsBubblePhase = [\r\n// mouse\r\n'mousedown', 'mousemove', 'mouseup', 'dragstart',\r\n// touch\r\n'touchstart', 'touchmove', 'touchend', 'touchcancel',\r\n// other\r\n'contextmenu', 'select', 'selectionchange'];\r\nexport function attachListeners() {\r\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\r\n    window.addEventListener('blur', eventListener);\r\n    documentEventsBubblePhase.forEach(eventType => {\r\n      document.addEventListener(eventType, eventListener);\r\n    });\r\n    documentEventsCapturePhase.forEach(eventType => {\r\n      document.addEventListener(eventType, eventListener, true);\r\n    });\r\n    window.__reactResponderSystemActive = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Register a node with the ResponderSystem.\r\n */\r\nexport function addNode(id, node, config) {\r\n  setResponderId(node, id);\r\n  responderListenersMap.set(id, config);\r\n}\r\n\r\n/**\r\n * Unregister a node with the ResponderSystem.\r\n */\r\nexport function removeNode(id) {\r\n  if (currentResponder.id === id) {\r\n    terminateResponder();\r\n  }\r\n  if (responderListenersMap.has(id)) {\r\n    responderListenersMap.delete(id);\r\n  }\r\n}\r\n\r\n/**\r\n * Allow the current responder to be terminated from within components to support\r\n * more complex requirements, such as use with other React libraries for working\r\n * with scroll views, input views, etc.\r\n */\r\nexport function terminateResponder() {\r\n  var _currentResponder3 = currentResponder,\r\n    id = _currentResponder3.id,\r\n    node = _currentResponder3.node;\r\n  if (id != null && node != null) {\r\n    var _getResponderConfig4 = getResponderConfig(id),\r\n      onResponderTerminate = _getResponderConfig4.onResponderTerminate;\r\n    if (onResponderTerminate != null) {\r\n      var event = createResponderEvent({}, responderTouchHistoryStore);\r\n      event.currentTarget = node;\r\n      onResponderTerminate(event);\r\n    }\r\n    changeCurrentResponder(emptyResponder);\r\n  }\r\n  isEmulatingMouseEvents = false;\r\n  trackedTouchCount = 0;\r\n}\r\n\r\n/**\r\n * Allow unit tests to inspect the current responder in the system.\r\n * FOR TESTING ONLY.\r\n */\r\nexport function getResponderNode() {\r\n  return currentResponder.node;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}